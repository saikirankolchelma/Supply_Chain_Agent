Supply Chain Agent  ğŸš€

Welcome to the Supply Chain Agent ! This document provides a comprehensive overview of the architecture, workflow, and implementation details of the agent. Letâ€™s dive in! ğŸ’»âœ¨

Overview ğŸŒŸ

The Supply Chain Agent is a conversational AI tool designed to assist distributors by answering queries related to stock availability, order status, and pricing changes. It integrates a Streamlit frontend , a FastAPI backend , and an SQLite database to deliver seamless responses to user queries. The agent leverages the Mistral 7B v1 large language model (LLM) to generate human-readable responses.


Video Demonstration ğŸ¥

For a better understanding of how the Supply Chain Agent works, check out the video demonstration below:

link: https://drive.google.com/file/d/1nRg6UyhlRhoFHXfFZ1f92ccdAp5pDXdo/view?usp=drivesdk

Application Architecture ğŸ—ï¸

Hereâ€™s a high-level overview of the application architecture:

    +-------------------+       +-------------------+       +-------------------+
    |                   |       |                   |       |                   |
    |   Streamlit       | ----> |   FastAPI         | ----> |   SQLite          |
    |   Frontend        |       |   Backend         |       |   Database        |
    |   (User Input)    |       |   (Query Parsing, |       |   (Supply Chain   |
    |                   |       |    SQL Queries)   |       |    Data Storage)  |
    |                   |       |                   |       |                   |
    +-------------------+       +-------------------+       +-------------------+

    
Detailed Architecture

1. Frontend Layer ğŸ–¥ï¸
   
     Built using Streamlit .
   
     Provides an interactive interface for users to enter queries.
   
     Sends user queries to the backend API via HTTP POST requests.
   
2. Backend Layer ğŸ§ 
 
    Built using FastAPI .
   
    Handles incoming queries from the frontend.
   
    Extracts intent and parameters (e.g., product name, order ID).
   
    Dynamically generates SQL queries based on the intent.

    Fetches data from the SQLite database.

    Formats the response using the Mistral 7B v1 LLM.
   
    Sends the formatted response back to the frontend.

   
4. Database Layer ğŸ—„ï¸
   
    Uses SQLite to store supply chain data (e.g., stock quantities, order statuses, prices).
   
    Executes SQL queries generated by the backend to retrieve required data.
   
6. Language Model Integration ğŸ¤–
   
    Leverages the Mistral 7B v1 LLM (via Hugging Face's huggingface_hub) to generate human-readable responses.
   
    Ensures that responses are clear, concise, and contextually accurate.
   
Application Workflow ğŸ› ï¸

Hereâ€™s how the application works step by step:

1. User Interaction on Frontend ğŸ‘¤
   
    The user enters a query in the Streamlit interface and clicks the "Submit" button.

        Example query: "What is the stock of ProductX?".
   
3. Frontend Sends Query to Backend ğŸ“¤
   
The frontend sends the query as a JSON payload to the FastAPI backend via an HTTP POST request:

    {
      "query": "What is the stock of ProductX?"
    }

5. Backend Processes the Query ğŸ§ 
   
The backend receives the query and performs the following steps:

a. Extract Intent and Parameters ğŸ”

Parses the query to extract relevant information (e.g., product name, order ID).

    Example: Extracts "ProductX" from "What is the stock of ProductX?".
    
b. Generate SQL Query ğŸ”§

Dynamically generates an SQL query based on the intent (stock, order status, price).

Example: For stock queries:

    SELECT stock_quantity FROM supply_chain WHERE product_name = 'ProductX';
    
c. Fetch Data from Database ğŸ—„ï¸

Executes the SQL query against the SQLite database (supply_chain.db) to retrieve the required data.

    Example result: 50 units in stock for ProductX.
    
d. Format Response âœï¸

Formats the fetched data into a human-readable response using the Mistral 7B v1 LLM.

    Example: "ProductX has 50 units in stock."
    
e. Return Response to Frontend ğŸ“¥

Sends the formatted response back to the frontend as a JSON object:

    {
      "response": "ProductX has 50 units in stock."
    }
    
4. Frontend Displays Response ğŸ‰
   
The frontend receives the response and displays it to the user in a user-friendly format.

Code Walkthrough ğŸ§©

1. Frontend (app.py) ğŸ–¥ï¸
   
Built using Streamlit to create a simple and interactive interface for users.

Key Features :

   Captures user input using st.text_input.
    
   Sends the query to the backend API using requests.post.
        
   Displays the response or error messages using Streamlit widgets like st.success, st.error, and st.warning.
        
3. Backend (chatbot.py) ğŸš€
           
Built using FastAPI to handle user queries and interact with the database.

 Key Features :
 
   Extracts parameters (e.g., product name, order ID) from user queries.
    
   Generates SQL queries dynamically based on the intent.
    
   Fetches data from the database using the SupplyChainDB class.
    
   Formats responses using the Mistral 7B v1 LLM.


5. Database (database.py) ğŸ—ƒï¸
   
Uses SQLite to store and retrieve supply chain data.

Key Features :

   Creates and populates the SQLite database with sample data.

   Executes SQL queries to fetch stock, order status, and price data.

   Returns formatted responses with emojis for better readability.

Example Responses ğŸ¯

Here are some example queries and their corresponding responses:

Query: "What is the stock of ProductX?"

Backend SQL Query :

    SELECT stock_quantity FROM supply_chain WHERE product_name = 'ProductX';
    Database Result : 50
    Response : "ProductX has 50 units in stock. âœ…"
    Query: "What is the status of order 123?"

Backend SQL Query :

    SELECT order_status FROM supply_chain WHERE order_id = 123;
    Database Result : "Shipped"
    Response : "Order #123 status: Shipped. âœ…"
    Query: "What is the price of ProductY?"
    
Backend SQL Query :

    SELECT current_price, old_price FROM supply_chain WHERE product_name = 'ProductY';
    Database Result : (5.99, 5.99)
    Response : "The price of ProductY is $5.99 (no recent changes). âœ…"

Query: "What is the stock of NonExistentProduct?"

    Database Result : None
    Response : "No data available for NonExistentProduct. âš ï¸"
    
Features ğŸŒŸ
   
   Natural Language Understanding : Parses user queries to extract relevant information (e.g., product name, order ID).
    
   Dynamic SQL Query Generation : Converts natural language queries into SQL queries to fetch data from the database.
    
   Database Integration : Uses SQLite to store and retrieve supply chain data (stock, orders, prices).
    
   Language Model Integration : Generates human-readable responses using the Mistral 7B v1 LLM.
    
   Interactive Frontend : Built with Streamlit for a user-friendly interface.
   
Setup Instructions ğŸ› ï¸

1. Clone the Repository
   
Clone the repository to your local machine:

    git clone https://github.com/your-username/supply-chain-agent.git
    cd supply-chain-agent
    2. Create a Conda Environment

We recommend using a Conda environment to manage dependencies:

    conda create -n supply_agent python=3.9
    conda activate supply_agent

3. Install Dependencies
   
Install the required Python packages using pip:

    pip install -r requirements.txt
  
Contents of requirements.txt :

streamlit 

fastapi

uvicorn

sqlite3

requests

langchain

huggingface_hub

python-dotenv

4. Set Up the .env File
   
Create a .env file in the root directory of the project and add your Hugging Face API key:

    HF_API_KEY=your_huggingface_api_key_here

5. Initialize the Database
   
The SQLite database (supply_chain.db) will be created automatically when you run the application for the first time. You can inspect or modify the database schema using tools like DB Browser for SQLite .

Running the Application ğŸš€

1. Start the Backend
   
Run the FastAPI backend using Uvicorn:

uvicorn backend.main:app --reload

The backend will start on http://127.0.0.1:8000.

2. Start the Frontend
   
Run the Streamlit frontend:

streamlit run frontend/app.py

The frontend will open in your browser at http://localhost:8501.


3. Test the Application
   
Enter a query in the Streamlit interface (e.g., "What is the stock of ProductX?") and click "Submit" to see the response.

Extending the Application ğŸŒ±

Feel free to extend this application by adding more features, such as:

Supporting additional intents (e.g., delivery dates, supplier details).

Switching to a more scalable database (e.g., PostgreSQL).

Deploying the application to a cloud platform for public access.

Contributing and License

Contributions are welcome! Please follow the guidelines in the CONTRIBUTING.md file.

Licensed under the MIT License.
